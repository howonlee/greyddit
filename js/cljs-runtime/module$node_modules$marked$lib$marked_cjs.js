shadow$provide.module$node_modules$marked$lib$marked_cjs = function(global, require, module, exports) {
  function _getDefaults() {
    return {async:!1, breaks:!1, extensions:null, gfm:!0, hooks:null, pedantic:!1, renderer:null, silent:!1, tokenizer:null, walkTokens:null};
  }
  function edit(regex, opt = "") {
    let source = "string" === typeof regex ? regex : regex.source;
    const obj = {replace:(name, val) => {
      val = "string" === typeof val ? val : val.source;
      val = val.replace(other.caret, "$1");
      source = source.replace(name, val);
      return obj;
    }, getRegex:() => new RegExp(source, opt)};
    return obj;
  }
  function escape(html, encode) {
    if (encode) {
      if (other.escapeTest.test(html)) {
        return html.replace(other.escapeReplace, getEscapeReplacement);
      }
    } else {
      if (other.escapeTestNoEncode.test(html)) {
        return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(other.percentDecode, "%");
    } catch {
      return null;
    }
    return href;
  }
  function splitCells(tableRow, count) {
    tableRow = tableRow.replace(other.findPipe, (match, offset, str) => {
      for (match = !1; 0 <= --offset && "\\" === str[offset];) {
        match = !match;
      }
      return match ? "|" : " |";
    }).split(other.splitPipe);
    let i = 0;
    tableRow[0].trim() || tableRow.shift();
    0 < tableRow.length && !tableRow.at(-1)?.trim() && tableRow.pop();
    if (count) {
      if (tableRow.length > count) {
        tableRow.splice(count);
      } else {
        for (; tableRow.length < count;) {
          tableRow.push("");
        }
      }
    }
    for (; i < tableRow.length; i++) {
      tableRow[i] = tableRow[i].trim().replace(other.slashPipe, "|");
    }
    return tableRow;
  }
  function rtrim(str, c, invert) {
    invert = str.length;
    if (0 === invert) {
      return "";
    }
    let suffLen = 0;
    for (; suffLen < invert;) {
      if (str.charAt(invert - suffLen - 1) === c) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, invert - suffLen);
  }
  function outputLink(cap, link, raw, lexer, rules) {
    const href = link.href;
    link = link.title || null;
    rules = cap[1].replace(rules.other.outputLinkReplace, "$1");
    return "!" !== cap[0].charAt(0) ? (lexer.state.inLink = !0, cap = {type:"link", raw, href, title:link, text:rules, tokens:lexer.inlineTokens(rules)}, lexer.state.inLink = !1, cap) : {type:"image", raw, href, title:link, text:rules};
  }
  function indentCodeCompensation(raw, text, rules) {
    raw = raw.match(rules.other.indentCodeCompensation);
    if (null === raw) {
      return text;
    }
    const indentToCode = raw[1];
    return text.split("\n").map(node => {
      var matchIndentInNode = node.match(rules.other.beginningSpace);
      if (null === matchIndentInNode) {
        return node;
      }
      [matchIndentInNode] = matchIndentInNode;
      return matchIndentInNode.length >= indentToCode.length ? node.slice(indentToCode.length) : node;
    }).join("\n");
  }
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  exports.defaults = _getDefaults();
  global = {exec:() => null};
  const other = {codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace:/\\([\[\]])/g, indentCodeCompensation:/^(\s+)(?:```)/, beginningSpace:/^\s+/, endingHash:/#$/, startingSpaceChar:/^ /, endingSpaceChar:/ $/, nonSpaceChar:/[^ ]/, newLineCharGlobal:/\n/g, tabCharGlobal:/\t/g, multipleSpaceGlobal:/\s+/g, blankLine:/^[ \t]*$/, doubleBlankLine:/\n[ \t]*\n[ \t]*$/, blockquoteStart:/^ {0,3}>/, blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm, 
  listReplaceTabs:/^\t+/, listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g, listIsTask:/^\[[ xX]\] /, listReplaceTask:/^\[[ xX]\] +/, anyLine:/\n.*\n/, hrefBrackets:/^<(.*)>$/, tableDelimiter:/[:|]/, tableAlignChars:/^\||\| *$/g, tableRowBlankLine:/\n[ \t]*$/, tableAlignRight:/^ *-+: *$/, tableAlignCenter:/^ *:-+: *$/, tableAlignLeft:/^ *:-+ *$/, startATag:/^<a /i, endATag:/^<\/a>/i, startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket:/^</, 
  endAngleBracket:/>$/, pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric:/[\p{L}\p{N}]/u, escapeTest:/[&<>"']/, escapeReplace:/[&<>"']/g, escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret:/(^|[^\[])\^/g, percentDecode:/%25/g, findPipe:/\|/g, splitPipe:/ \|/, slashPipe:/\\\|/g, carriageReturn:/\r\n|\r/g, spaceLine:/^ +$/gm, 
  notSpaceStart:/^\S*/, endingNewline:/\n$/, listItemRegex:bull => new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`), nextBulletRegex:indent => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`), hrRegex:indent => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex:indent => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex:indent => new RegExp(`^ {0,${Math.min(3, 
  indent - 1)}}#`), htmlBeginRegex:indent => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")};
  var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/;
  require = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
  var lheading = edit(require).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), lheadingGfm = edit(require).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, 
  / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[:\- ]*\n/).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  module = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  require = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", module).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  bullet = /\x3c!--(?:-?>|[\s\S]*?(?:--\x3e|$))/;
  var html = edit("^ {0,3}(?:\x3c(script|pre|style|textarea)[\\s\x3e][\\s\\S]*?(?:\x3c/\\1\x3e[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|\x3c\\?[\\s\\S]*?(?:\\?\x3e\\n*|$)|\x3c![A-Z][\\s\\S]*?(?:\x3e\\n*|$)|\x3c!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]\x3e\\n*|$)|\x3c/?(tag)(?: +|\\n|/?\x3e)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|\x3c(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?\x3e(?\x3d[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|\x3c/(?!script|pre|style|textarea)[a-z][\\w-]*\\s*\x3e(?\x3d[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$))", 
  "i").replace("comment", bullet).replace("tag", "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul").replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), 
  paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}\x3e").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul").getRegex();
  require = {blockquote:edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), code:/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, def:require, fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, hr, html, lheading, list, newline:/^(?:[ \t]*(?:\n|$))+/, paragraph, table:global, text:/^[^\n]+/};
  list = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}\x3e").replace("code", "(?: {4}| {0,3}\t)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", 
  "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul").getRegex();
  lheadingGfm = {...require, lheading:lheadingGfm, table:list, paragraph:edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", list).replace("blockquote", " {0,3}\x3e").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul").getRegex()};
  hr = {...require, html:edit("^ *(?:comment *(?:\\n|\\s*$)|\x3c(tag)[\\s\\S]+?\x3c/\\1\x3e *(?:\\n{2,}|\\s*$)|\x3ctag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/\x3e\\s]*)*?/?\x3e *(?:\\n{2,}|\\s*$))").replace("comment", bullet).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading:/^(#{1,6})(.*)(?:\n+|$)/, 
  fences:global, lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph:edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}\x3e").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()};
  lheading = /^( {2,}|\\)\n(?!\s*$)/;
  var _punctuation = /[\p{P}\p{S}]/u, _punctuationOrSpace = /[\s\p{P}\p{S}]/u, _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
  list = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
  paragraph = /(?!~)[\p{P}\p{S}]/u;
  _paragraph = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
  html = edit(_paragraph, "u").replace(/punct/g, _punctuation).getRegex();
  _paragraph = edit(_paragraph, "u").replace(/punct/g, paragraph).getRegex();
  const emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?\x3d__)|[^*]+(?\x3d[^*])|(?!\\*)punct(\\*+)(?\x3d[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?\x3dpunctSpace|$)|(?!\\*)punctSpace(\\*+)(?\x3dnotPunctSpace)|[\\s](\\*+)(?!\\*)(?\x3dpunct)|(?!\\*)punct(\\*+)(?!\\*)(?\x3dpunct)|notPunctSpace(\\*+)(?\x3dnotPunctSpace)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  paragraph = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?\x3d__)|[^*]+(?\x3d[^*])|(?!\\*)punct(\\*+)(?\x3d[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?\x3dpunctSpace|$)|(?!\\*)punctSpace(\\*+)(?\x3dnotPunctSpace)|[\\s](\\*+)(?!\\*)(?\x3dpunct)|(?!\\*)punct(\\*+)(?!\\*)(?\x3dpunct)|notPunctSpace(\\*+)(?\x3dnotPunctSpace)", "gu").replace(/notPunctSpace/g, /(?:[^\s\p{P}\p{S}]|~)/u).replace(/punctSpace/g, /(?!~)[\s\p{P}\p{S}]/u).replace(/punct/g, paragraph).getRegex();
  _punctuationOrSpace = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?\x3d\\*\\*)|[^_]+(?\x3d[^_])|(?!_)punct(_+)(?\x3d[\\s]|$)|notPunctSpace(_+)(?!_)(?\x3dpunctSpace|$)|(?!_)punctSpace(_+)(?\x3dnotPunctSpace)|[\\s](_+)(?!_)(?\x3dpunct)|(?!_)punct(_+)(?!_)(?\x3dpunct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  _punctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
  _notPunctuationOrSpace = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  bullet = edit(bullet).replace("(?:--\x3e|$)", "--\x3e").getRegex();
  const tag = edit("^comment|^\x3c/[a-zA-Z][\\w:-]*\\s*\x3e|^\x3c[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?\x3e|^\x3c\\?[\\s\\S]*?\\?\x3e|^\x3c![a-zA-Z]+\\s[\\s\\S]*?\x3e|^\x3c!\\[CDATA\\[[\\s\\S]*?\\]\\]\x3e").replace("comment", bullet).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  bullet = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  const link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", bullet).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", bullet).replace("ref", module).getRegex();
  module = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", module).getRegex();
  const reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", module).getRegex();
  global = {_backpedal:global, anyPunctuation:_punctuation, autolink:_notPunctuationOrSpace, blockSkip:/\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, br:lheading, code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, del:global, emStrongLDelim:html, emStrongRDelimAst, emStrongRDelimUnd:_punctuationOrSpace, escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, link, nolink:module, punctuation:list, reflink, reflinkSearch, tag, text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, 
  url:global};
  module = {...global, link:edit(/^!?\[(label)\]\((.*?)\)/).replace("label", bullet).getRegex(), reflink:edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", bullet).getRegex()};
  bullet = {...global, emStrongRDelimAst:paragraph, emStrongLDelim:_paragraph, url:edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del:/^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/};
  lheading = {...bullet, br:edit(lheading).replace("{2,}", "*").getRegex(), text:edit(bullet.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()};
  const block = {normal:require, gfm:lheadingGfm, pedantic:hr}, inline = {normal:global, gfm:bullet, breaks:lheading, pedantic:module}, escapeReplacements = {"\x26":"\x26amp;", "\x3c":"\x26lt;", "\x3e":"\x26gt;", '"':"\x26quot;", "'":"\x26#39;"}, getEscapeReplacement = ch => escapeReplacements[ch];
  class _Tokenizer {
    constructor(options) {
      this.options = options || exports.defaults;
    }
    space(src) {
      if ((src = this.rules.block.newline.exec(src)) && 0 < src[0].length) {
        return {type:"space", raw:src[0]};
      }
    }
    code(src) {
      if (src = this.rules.block.code.exec(src)) {
        const text = src[0].replace(this.rules.other.codeRemoveIndent, "");
        return {type:"code", raw:src[0], codeBlockStyle:"indented", text:this.options.pedantic ? text : rtrim(text, "\n")};
      }
    }
    fences(src) {
      if (src = this.rules.block.fences.exec(src)) {
        const raw = src[0], text = indentCodeCompensation(raw, src[3] || "", this.rules);
        return {type:"code", raw, lang:src[2] ? src[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : src[2], text};
      }
    }
    heading(src) {
      if (src = this.rules.block.heading.exec(src)) {
        let text = src[2].trim();
        if (this.rules.other.endingHash.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {type:"heading", raw:src[0], depth:src[1].length, text, tokens:this.lexer.inline(text)};
      }
    }
    hr(src) {
      if (src = this.rules.block.hr.exec(src)) {
        return {type:"hr", raw:rtrim(src[0], "\n")};
      }
    }
    blockquote(src) {
      if (src = this.rules.block.blockquote.exec(src)) {
        var lines = rtrim(src[0], "\n").split("\n");
        let text = src = "";
        const tokens = [];
        for (; 0 < lines.length;) {
          var inBlockquote = !1, currentLines = [], i = void 0;
          for (i = 0; i < lines.length; i++) {
            if (this.rules.other.blockquoteStart.test(lines[i])) {
              currentLines.push(lines[i]), inBlockquote = !0;
            } else if (inBlockquote) {
              break;
            } else {
              currentLines.push(lines[i]);
            }
          }
          lines = lines.slice(i);
          currentLines = currentLines.join("\n");
          inBlockquote = currentLines.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
          src = src ? `${src}\n${currentLines}` : currentLines;
          text = text ? `${text}\n${inBlockquote}` : inBlockquote;
          currentLines = this.lexer.state.top;
          this.lexer.state.top = !0;
          this.lexer.blockTokens(inBlockquote, tokens, !0);
          this.lexer.state.top = currentLines;
          if (0 === lines.length) {
            break;
          }
          inBlockquote = tokens.at(-1);
          if ("code" === inBlockquote?.type) {
            break;
          } else if ("blockquote" === inBlockquote?.type) {
            lines = inBlockquote.raw + "\n" + lines.join("\n");
            lines = this.blockquote(lines);
            tokens[tokens.length - 1] = lines;
            src = src.substring(0, src.length - inBlockquote.raw.length) + lines.raw;
            text = text.substring(0, text.length - inBlockquote.text.length) + lines.text;
            break;
          } else {
            "list" === inBlockquote?.type && (currentLines = inBlockquote, lines = currentLines.raw + "\n" + lines.join("\n"), i = this.list(lines), tokens[tokens.length - 1] = i, src = src.substring(0, src.length - inBlockquote.raw.length) + i.raw, text = text.substring(0, text.length - currentLines.raw.length) + i.raw, lines = lines.substring(tokens.at(-1).raw.length).split("\n"));
          }
        }
        return {type:"blockquote", raw:src, tokens, text};
      }
    }
    list(src) {
      var cap = this.rules.block.list.exec(src);
      if (cap) {
        var bull = cap[1].trim(), isordered = 1 < bull.length;
        const list = {type:"list", raw:"", ordered:isordered, start:isordered ? +bull.slice(0, -1) : "", loose:!1, items:[]};
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        this.options.pedantic && (bull = isordered ? bull : "[*+-]");
        bull = this.rules.other.listItemRegex(bull);
        for (isordered = !1; src;) {
          var endEarly = !1;
          let raw = "", itemContents = "";
          if (!(cap = bull.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          var line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, t => " ".repeat(3 * t.length));
          let nextLine = src.split("\n", 1)[0], blankLine = !line.trim(), indent = 0;
          this.options.pedantic ? (indent = 2, itemContents = line.trimStart()) : blankLine ? indent = cap[1].length + 1 : (indent = cap[2].search(this.rules.other.nonSpaceChar), indent = 4 < indent ? 1 : indent, itemContents = line.slice(indent), indent += cap[1].length);
          blankLine && this.rules.other.blankLine.test(nextLine) && (raw += nextLine + "\n", src = src.substring(nextLine.length + 1), endEarly = !0);
          if (!endEarly) {
            cap = this.rules.other.nextBulletRegex(indent);
            endEarly = this.rules.other.hrRegex(indent);
            const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent), headingBeginRegex = this.rules.other.headingBeginRegex(indent), htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
            for (; src;) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              nextLineWithoutTabs = this.options.pedantic ? nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ") : nextLine.replace(this.rules.other.tabCharGlobal, "    ");
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (htmlBeginRegex.test(nextLine)) {
                break;
              }
              if (cap.test(nextLine)) {
                break;
              }
              if (endEarly.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (4 <= line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar)) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (endEarly.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              blankLine || nextLine.trim() || (blankLine = !0);
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent);
            }
          }
          list.loose || (isordered ? list.loose = !0 : this.rules.other.doubleBlankLine.test(raw) && (isordered = !0));
          line = null;
          var ischecked = void 0;
          this.options.gfm && (line = this.rules.other.listIsTask.exec(itemContents)) && (ischecked = "[ ] " !== line[0], itemContents = itemContents.replace(this.rules.other.listReplaceTask, ""));
          list.items.push({type:"list_item", raw, task:!!line, checked:ischecked, loose:!1, text:itemContents, tokens:[]});
          list.raw += raw;
        }
        if (src = list.items.at(-1)) {
          src.raw = src.raw.trimEnd();
          src.text = src.text.trimEnd();
          list.raw = list.raw.trimEnd();
          for (src = 0; src < list.items.length; src++) {
            this.lexer.state.top = !1, list.items[src].tokens = this.lexer.blockTokens(list.items[src].text, []), list.loose || (ischecked = list.items[src].tokens.filter(t => "space" === t.type), ischecked = 0 < ischecked.length && ischecked.some(t => this.rules.other.anyLine.test(t.raw)), list.loose = ischecked);
          }
          if (list.loose) {
            for (src = 0; src < list.items.length; src++) {
              list.items[src].loose = !0;
            }
          }
          return list;
        }
      }
    }
    html(src) {
      if (src = this.rules.block.html.exec(src)) {
        return {type:"html", block:!0, raw:src[0], pre:"pre" === src[1] || "script" === src[1] || "style" === src[1], text:src[0]};
      }
    }
    def(src) {
      if (src = this.rules.block.def.exec(src)) {
        const tag = src[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), href = src[2] ? src[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", title = src[3] ? src[3].substring(1, src[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : src[3];
        return {type:"def", tag, raw:src[0], href, title};
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (cap && this.rules.other.tableDelimiter.test(cap[2])) {
        src = splitCells(cap[1]);
        var aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|"), rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [], item = {type:"table", raw:cap[0], header:[], align:[], rows:[]};
        if (src.length === aligns.length) {
          for (var align of aligns) {
            this.rules.other.tableAlignRight.test(align) ? item.align.push("right") : this.rules.other.tableAlignCenter.test(align) ? item.align.push("center") : this.rules.other.tableAlignLeft.test(align) ? item.align.push("left") : item.align.push(null);
          }
          for (align = 0; align < src.length; align++) {
            item.header.push({text:src[align], tokens:this.lexer.inline(src[align]), header:!0, align:item.align[align]});
          }
          for (const row of rows) {
            item.rows.push(splitCells(row, item.header.length).map((cell, i) => ({text:cell, tokens:this.lexer.inline(cell), header:!1, align:item.align[i]})));
          }
          return item;
        }
      }
    }
    lheading(src) {
      if (src = this.rules.block.lheading.exec(src)) {
        return {type:"heading", raw:src[0], depth:"\x3d" === src[2].charAt(0) ? 1 : 2, text:src[1], tokens:this.lexer.inline(src[1])};
      }
    }
    paragraph(src) {
      if (src = this.rules.block.paragraph.exec(src)) {
        const text = "\n" === src[1].charAt(src[1].length - 1) ? src[1].slice(0, -1) : src[1];
        return {type:"paragraph", raw:src[0], text, tokens:this.lexer.inline(text)};
      }
    }
    text(src) {
      if (src = this.rules.block.text.exec(src)) {
        return {type:"text", raw:src[0], text:src[0], tokens:this.lexer.inline(src[0])};
      }
    }
    escape(src) {
      if (src = this.rules.inline.escape.exec(src)) {
        return {type:"escape", raw:src[0], text:src[1]};
      }
    }
    tag(src) {
      if (src = this.rules.inline.tag.exec(src)) {
        return !this.lexer.state.inLink && this.rules.other.startATag.test(src[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(src[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(src[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(src[0]) && (this.lexer.state.inRawBlock = !1), {type:"html", raw:src[0], inLink:this.lexer.state.inLink, 
        inRawBlock:this.lexer.state.inRawBlock, block:!1, text:src[0]};
      }
    }
    link(src) {
      if (src = this.rules.inline.link.exec(src)) {
        const trimmedUrl = src[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
          if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
            return;
          }
          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if (0 === (trimmedUrl.length - rtrimSlash.length) % 2) {
            return;
          }
        } else {
          a: {
            if (rtrimSlash = src[2], -1 === rtrimSlash.indexOf(")")) {
              rtrimSlash = -1;
            } else {
              var level = 0;
              for (var i = 0; i < rtrimSlash.length; i++) {
                if ("\\" === rtrimSlash[i]) {
                  i++;
                } else if ("(" === rtrimSlash[i]) {
                  level++;
                } else if (")" === rtrimSlash[i] && (level--, 0 > level)) {
                  rtrimSlash = i;
                  break a;
                }
              }
              rtrimSlash = 0 < level ? -2 : -1;
            }
          }
          if (-2 === rtrimSlash) {
            return;
          }
          -1 < rtrimSlash && (level = (0 === src[0].indexOf("!") ? 5 : 4) + src[1].length + rtrimSlash, src[2] = src[2].substring(0, rtrimSlash), src[0] = src[0].substring(0, level).trim(), src[3] = "");
        }
        rtrimSlash = src[2];
        level = "";
        if (this.options.pedantic) {
          if (i = this.rules.other.pedanticHrefTitle.exec(rtrimSlash)) {
            rtrimSlash = i[1], level = i[3];
          }
        } else {
          level = src[3] ? src[3].slice(1, -1) : "";
        }
        rtrimSlash = rtrimSlash.trim();
        this.rules.other.startAngleBracket.test(rtrimSlash) && (rtrimSlash = this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl) ? rtrimSlash.slice(1) : rtrimSlash.slice(1, -1));
        return outputLink(src, {href:rtrimSlash ? rtrimSlash.replace(this.rules.inline.anyPunctuation, "$1") : rtrimSlash, title:level ? level.replace(this.rules.inline.anyPunctuation, "$1") : level}, src[0], this.lexer, this.rules);
      }
    }
    reflink(src, links) {
      var cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        return src = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " "), links = links[src.toLowerCase()], links ? outputLink(cap, links, cap[0], this.lexer, this.rules) : (cap = cap[0].charAt(0), {type:"text", raw:cap, text:cap});
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      var match = this.rules.inline.emStrongLDelim.exec(src);
      if (!(!match || match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric) || (match[1] || match[2]) && prevChar && !this.rules.inline.punctuation.exec(prevChar))) {
        prevChar = [...match[0]].length - 1;
        var rDelim;
        let delimTotal = prevChar, midDelimTotal = 0;
        const endReg = "*" === match[0][0] ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        for (maskedSrc = maskedSrc.slice(-1 * src.length + prevChar); null != (match = endReg.exec(maskedSrc));) {
          if (rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6]) {
            if (rDelim = [...rDelim].length, match[3] || match[4]) {
              delimTotal += rDelim;
            } else if ((match[5] || match[6]) && prevChar % 3 && !((prevChar + rDelim) % 3)) {
              midDelimTotal += rDelim;
            } else {
              if (delimTotal -= rDelim, !(0 < delimTotal)) {
                rDelim = Math.min(rDelim, rDelim + delimTotal + midDelimTotal);
                maskedSrc = [...match[0]][0].length;
                src = src.slice(0, prevChar + match.index + maskedSrc + rDelim);
                if (Math.min(prevChar, rDelim) % 2) {
                  return match = src.slice(1, -1), {type:"em", raw:src, text:match, tokens:this.lexer.inlineTokens(match)};
                }
                match = src.slice(2, -2);
                return {type:"strong", raw:src, text:match, tokens:this.lexer.inlineTokens(match)};
              }
            }
          }
        }
      }
    }
    codespan(src) {
      if (src = this.rules.inline.code.exec(src)) {
        let text = src[2].replace(this.rules.other.newLineCharGlobal, " ");
        const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text), hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
        hasNonSpaceChars && hasSpaceCharsOnBothEnds && (text = text.substring(1, text.length - 1));
        return {type:"codespan", raw:src[0], text};
      }
    }
    br(src) {
      if (src = this.rules.inline.br.exec(src)) {
        return {type:"br", raw:src[0]};
      }
    }
    del(src) {
      if (src = this.rules.inline.del.exec(src)) {
        return {type:"del", raw:src[0], text:src[2], tokens:this.lexer.inlineTokens(src[2])};
      }
    }
    autolink(src) {
      if (src = this.rules.inline.autolink.exec(src)) {
        let text, href;
        "@" === src[2] ? (text = src[1], href = "mailto:" + text) : href = text = src[1];
        return {type:"link", raw:src[0], text, href, tokens:[{type:"text", raw:text, text}]};
      }
    }
    url(src) {
      if (src = this.rules.inline.url.exec(src)) {
        let href;
        if ("@" === src[2]) {
          var text = src[0];
          href = "mailto:" + text;
        } else {
          do {
            text = src[0], src[0] = this.rules.inline._backpedal.exec(src[0])?.[0] ?? "";
          } while (text !== src[0]);
          text = src[0];
          href = "www." === src[1] ? "http://" + src[0] : src[0];
        }
        return {type:"link", raw:src[0], text, href, tokens:[{type:"text", raw:text, text}]};
      }
    }
    inlineText(src) {
      if (src = this.rules.inline.text.exec(src)) {
        return {type:"text", raw:src[0], text:src[0], escaped:this.lexer.state.inRawBlock};
      }
    }
  }
  class _Lexer {
    constructor(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || exports.defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {inLink:!1, inRawBlock:!1, top:!0};
      options = {other, block:block.normal, inline:inline.normal};
      this.options.pedantic ? (options.block = block.pedantic, options.inline = inline.pedantic) : this.options.gfm && (options.block = block.gfm, options.inline = this.options.breaks ? inline.breaks : inline.gfm);
      this.tokenizer.rules = options;
    }
    static get rules() {
      return {block, inline};
    }
    static lex(src, options) {
      return (new _Lexer(options)).lex(src);
    }
    static lexInline(src, options) {
      return (new _Lexer(options)).inlineTokens(src);
    }
    lex(src) {
      src = src.replace(other.carriageReturn, "\n");
      this.blockTokens(src, this.tokens);
      for (src = 0; src < this.inlineQueue.length; src++) {
        const next = this.inlineQueue[src];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = !1) {
      for (this.options.pedantic && (src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "")); src;) {
        let token;
        if (!this.options.extensions?.block?.some(extTokenizer => (token = extTokenizer.call({lexer:this}, src, tokens)) ? (src = src.substring(token.raw.length), tokens.push(token), !0) : !1)) {
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            var lastToken$jscomp$0 = tokens.at(-1);
            1 === token.raw.length && void 0 !== lastToken$jscomp$0 ? lastToken$jscomp$0.raw += "\n" : tokens.push(token);
          } else {
            if (token = this.tokenizer.code(src)) {
              src = src.substring(token.raw.length), lastToken$jscomp$0 = tokens.at(-1), "paragraph" === lastToken$jscomp$0?.type || "text" === lastToken$jscomp$0?.type ? (lastToken$jscomp$0.raw += "\n" + token.raw, lastToken$jscomp$0.text += "\n" + token.text, this.inlineQueue.at(-1).src = lastToken$jscomp$0.text) : tokens.push(token);
            } else {
              if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length), tokens.push(token);
              } else {
                if (token = this.tokenizer.heading(src)) {
                  src = src.substring(token.raw.length), tokens.push(token);
                } else {
                  if (token = this.tokenizer.hr(src)) {
                    src = src.substring(token.raw.length), tokens.push(token);
                  } else {
                    if (token = this.tokenizer.blockquote(src)) {
                      src = src.substring(token.raw.length), tokens.push(token);
                    } else {
                      if (token = this.tokenizer.list(src)) {
                        src = src.substring(token.raw.length), tokens.push(token);
                      } else {
                        if (token = this.tokenizer.html(src)) {
                          src = src.substring(token.raw.length), tokens.push(token);
                        } else {
                          if (token = this.tokenizer.def(src)) {
                            src = src.substring(token.raw.length), lastToken$jscomp$0 = tokens.at(-1), "paragraph" === lastToken$jscomp$0?.type || "text" === lastToken$jscomp$0?.type ? (lastToken$jscomp$0.raw += "\n" + token.raw, lastToken$jscomp$0.text += "\n" + token.raw, this.inlineQueue.at(-1).src = lastToken$jscomp$0.text) : this.tokens.links[token.tag] || (this.tokens.links[token.tag] = {href:token.href, title:token.title});
                          } else {
                            if (token = this.tokenizer.table(src)) {
                              src = src.substring(token.raw.length), tokens.push(token);
                            } else {
                              if (token = this.tokenizer.lheading(src)) {
                                src = src.substring(token.raw.length), tokens.push(token);
                              } else {
                                lastToken$jscomp$0 = src;
                                if (this.options.extensions?.startBlock) {
                                  let startIndex = Infinity;
                                  const tempSrc = src.slice(1);
                                  let tempStart;
                                  this.options.extensions.startBlock.forEach(getStartIndex => {
                                    tempStart = getStartIndex.call({lexer:this}, tempSrc);
                                    "number" === typeof tempStart && 0 <= tempStart && (startIndex = Math.min(startIndex, tempStart));
                                  });
                                  Infinity > startIndex && 0 <= startIndex && (lastToken$jscomp$0 = src.substring(0, startIndex + 1));
                                }
                                if (this.state.top && (token = this.tokenizer.paragraph(lastToken$jscomp$0))) {
                                  const lastToken = tokens.at(-1);
                                  lastParagraphClipped && "paragraph" === lastToken?.type ? (lastToken.raw += "\n" + token.raw, lastToken.text += "\n" + token.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = lastToken.text) : tokens.push(token);
                                  lastParagraphClipped = lastToken$jscomp$0.length !== src.length;
                                  src = src.substring(token.raw.length);
                                } else {
                                  if (token = this.tokenizer.text(src)) {
                                    src = src.substring(token.raw.length), lastToken$jscomp$0 = tokens.at(-1), "text" === lastToken$jscomp$0?.type ? (lastToken$jscomp$0.raw += "\n" + token.raw, lastToken$jscomp$0.text += "\n" + token.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = lastToken$jscomp$0.text) : tokens.push(token);
                                  } else {
                                    if (src) {
                                      if (lastParagraphClipped = "Infinite loop on byte: " + src.charCodeAt(0), this.options.silent) {
                                        console.error(lastParagraphClipped);
                                        break;
                                      } else {
                                        throw Error(lastParagraphClipped);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      this.state.top = !0;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({src, tokens});
      return tokens;
    }
    inlineTokens(src, tokens = []) {
      var maskedSrc = src, match = null;
      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);
        if (0 < links.length) {
          for (; null != (match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc));) {
            links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1)) && (maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
          }
        }
      }
      for (; null != (match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc));) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      for (; null != (match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc));) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      match = !1;
      for (links = ""; src;) {
        match || (links = "");
        match = !1;
        let token;
        if (!this.options.extensions?.inline?.some(extTokenizer => (token = extTokenizer.call({lexer:this}, src, tokens)) ? (src = src.substring(token.raw.length), tokens.push(token), !0) : !1)) {
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length), tokens.push(token);
          } else {
            if (token = this.tokenizer.tag(src)) {
              src = src.substring(token.raw.length), tokens.push(token);
            } else {
              if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length), tokens.push(token);
              } else {
                if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                  src = src.substring(token.raw.length);
                  var lastToken = tokens.at(-1);
                  "text" === token.type && "text" === lastToken?.type ? (lastToken.raw += token.raw, lastToken.text += token.text) : tokens.push(token);
                } else {
                  if (token = this.tokenizer.emStrong(src, maskedSrc, links)) {
                    src = src.substring(token.raw.length), tokens.push(token);
                  } else {
                    if (token = this.tokenizer.codespan(src)) {
                      src = src.substring(token.raw.length), tokens.push(token);
                    } else {
                      if (token = this.tokenizer.br(src)) {
                        src = src.substring(token.raw.length), tokens.push(token);
                      } else {
                        if (token = this.tokenizer.del(src)) {
                          src = src.substring(token.raw.length), tokens.push(token);
                        } else {
                          if (token = this.tokenizer.autolink(src)) {
                            src = src.substring(token.raw.length), tokens.push(token);
                          } else {
                            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                              src = src.substring(token.raw.length), tokens.push(token);
                            } else {
                              lastToken = src;
                              if (this.options.extensions?.startInline) {
                                let startIndex = Infinity;
                                const tempSrc = src.slice(1);
                                let tempStart;
                                this.options.extensions.startInline.forEach(getStartIndex => {
                                  tempStart = getStartIndex.call({lexer:this}, tempSrc);
                                  "number" === typeof tempStart && 0 <= tempStart && (startIndex = Math.min(startIndex, tempStart));
                                });
                                Infinity > startIndex && 0 <= startIndex && (lastToken = src.substring(0, startIndex + 1));
                              }
                              if (token = this.tokenizer.inlineText(lastToken)) {
                                src = src.substring(token.raw.length), "_" !== token.raw.slice(-1) && (links = token.raw.slice(-1)), match = !0, lastToken = tokens.at(-1), "text" === lastToken?.type ? (lastToken.raw += token.raw, lastToken.text += token.text) : tokens.push(token);
                              } else {
                                if (src) {
                                  if (maskedSrc = "Infinite loop on byte: " + src.charCodeAt(0), this.options.silent) {
                                    console.error(maskedSrc);
                                    break;
                                  } else {
                                    throw Error(maskedSrc);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return tokens;
    }
  }
  class _Renderer {
    constructor(options) {
      this.options = options || exports.defaults;
    }
    space(token) {
      return "";
    }
    code({text, lang, escaped}) {
      lang = (lang || "").match(other.notSpaceStart)?.[0];
      text = text.replace(other.endingNewline, "") + "\n";
      return lang ? '\x3cpre\x3e\x3ccode class\x3d"language-' + escape(lang) + '"\x3e' + (escaped ? text : escape(text, !0)) + "\x3c/code\x3e\x3c/pre\x3e\n" : "\x3cpre\x3e\x3ccode\x3e" + (escaped ? text : escape(text, !0)) + "\x3c/code\x3e\x3c/pre\x3e\n";
    }
    blockquote({tokens}) {
      return `<blockquote>\n${this.parser.parse(tokens)}</blockquote>\n`;
    }
    html({text}) {
      return text;
    }
    heading({tokens, depth}) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
    }
    hr(token) {
      return "\x3chr\x3e\n";
    }
    list(token) {
      const ordered = token.ordered, start = token.start;
      let body = "";
      for (let j = 0; j < token.items.length; j++) {
        body += this.listitem(token.items[j]);
      }
      token = ordered ? "ol" : "ul";
      return "\x3c" + token + (ordered && 1 !== start ? ' start\x3d"' + start + '"' : "") + "\x3e\n" + body + "\x3c/" + token + "\x3e\n";
    }
    listitem(item) {
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({checked:!!item.checked});
        item.loose ? "paragraph" === item.tokens[0]?.type ? (item.tokens[0].text = checkbox + " " + item.tokens[0].text, item.tokens[0].tokens && 0 < item.tokens[0].tokens.length && "text" === item.tokens[0].tokens[0].type && (item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text), item.tokens[0].tokens[0].escaped = !0)) : item.tokens.unshift({type:"text", raw:checkbox + " ", text:checkbox + " ", escaped:!0}) : itemBody += checkbox + " ";
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>\n`;
    }
    checkbox({checked}) {
      return "\x3cinput " + (checked ? 'checked\x3d"" ' : "") + 'disabled\x3d"" type\x3d"checkbox"\x3e';
    }
    paragraph({tokens}) {
      return `<p>${this.parser.parseInline(tokens)}</p>\n`;
    }
    table(token) {
      let header = "", cell = "";
      for (var j$jscomp$0 = 0; j$jscomp$0 < token.header.length; j$jscomp$0++) {
        cell += this.tablecell(token.header[j$jscomp$0]);
      }
      header += this.tablerow({text:cell});
      j$jscomp$0 = "";
      for (let j = 0; j < token.rows.length; j++) {
        const row = token.rows[j];
        cell = "";
        for (let k = 0; k < row.length; k++) {
          cell += this.tablecell(row[k]);
        }
        j$jscomp$0 += this.tablerow({text:cell});
      }
      j$jscomp$0 && (j$jscomp$0 = `<tbody>${j$jscomp$0}</tbody>`);
      return "\x3ctable\x3e\n\x3cthead\x3e\n" + header + "\x3c/thead\x3e\n" + j$jscomp$0 + "\x3c/table\x3e\n";
    }
    tablerow({text}) {
      return `<tr>\n${text}</tr>\n`;
    }
    tablecell(token) {
      const content = this.parser.parseInline(token.tokens), type = token.header ? "th" : "td";
      return (token.align ? `<${type} align="${token.align}">` : `<${type}>`) + content + `</${type}>\n`;
    }
    strong({tokens}) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({tokens}) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({text}) {
      return `<code>${escape(text, !0)}</code>`;
    }
    br(token) {
      return "\x3cbr\x3e";
    }
    del({tokens}) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({href, title, tokens}) {
      tokens = this.parser.parseInline(tokens);
      href = cleanUrl(href);
      if (null === href) {
        return tokens;
      }
      href = '\x3ca href\x3d"' + href + '"';
      title && (href += ' title\x3d"' + escape(title) + '"');
      return href + ("\x3e" + tokens + "\x3c/a\x3e");
    }
    image({href, title, text}) {
      href = cleanUrl(href);
      if (null === href) {
        return escape(text);
      }
      text = `<img src="${href}" alt="${text}"`;
      title && (text += ` title="${escape(title)}"`);
      return text + "\x3e";
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
    }
  }
  class _TextRenderer {
    strong({text}) {
      return text;
    }
    em({text}) {
      return text;
    }
    codespan({text}) {
      return text;
    }
    del({text}) {
      return text;
    }
    html({text}) {
      return text;
    }
    text({text}) {
      return text;
    }
    link({text}) {
      return "" + text;
    }
    image({text}) {
      return "" + text;
    }
    br() {
      return "";
    }
  }
  class _Parser {
    constructor(options) {
      this.options = options || exports.defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    static parse(tokens, options) {
      return (new _Parser(options)).parse(tokens);
    }
    static parseInline(tokens, options) {
      return (new _Parser(options)).parseInline(tokens);
    }
    parse(tokens, top = !0) {
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        var anyToken = tokens[i];
        if (this.options.extensions?.renderers?.[anyToken.type]) {
          var genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({parser:this}, genericToken);
          if (!1 !== ret || !"space hr heading code table blockquote list html paragraph text".split(" ").includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        switch(anyToken.type) {
          case "space":
            out += this.renderer.space(anyToken);
            continue;
          case "hr":
            out += this.renderer.hr(anyToken);
            continue;
          case "heading":
            out += this.renderer.heading(anyToken);
            continue;
          case "code":
            out += this.renderer.code(anyToken);
            continue;
          case "table":
            out += this.renderer.table(anyToken);
            continue;
          case "blockquote":
            out += this.renderer.blockquote(anyToken);
            continue;
          case "list":
            out += this.renderer.list(anyToken);
            continue;
          case "html":
            out += this.renderer.html(anyToken);
            continue;
          case "paragraph":
            out += this.renderer.paragraph(anyToken);
            continue;
          case "text":
            for (genericToken = this.renderer.text(anyToken); i + 1 < tokens.length && "text" === tokens[i + 1].type;) {
              anyToken = tokens[++i], genericToken += "\n" + this.renderer.text(anyToken);
            }
            out = top ? out + this.renderer.paragraph({type:"paragraph", raw:genericToken, text:genericToken, tokens:[{type:"text", raw:genericToken, text:genericToken, escaped:!0}]}) : out + genericToken;
            continue;
          default:
            tokens = 'Token with "' + anyToken.type + '" type was not found.';
            if (this.options.silent) {
              return console.error(tokens), "";
            }
            throw Error(tokens);
        }
      }
      return out;
    }
    parseInline(tokens, renderer = this.renderer) {
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        var anyToken = tokens[i];
        if (this.options.extensions?.renderers?.[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({parser:this}, anyToken);
          if (!1 !== ret || !"escape html link image strong em codespan br del text".split(" ").includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        switch(anyToken.type) {
          case "escape":
            out += renderer.text(anyToken);
            break;
          case "html":
            out += renderer.html(anyToken);
            break;
          case "link":
            out += renderer.link(anyToken);
            break;
          case "image":
            out += renderer.image(anyToken);
            break;
          case "strong":
            out += renderer.strong(anyToken);
            break;
          case "em":
            out += renderer.em(anyToken);
            break;
          case "codespan":
            out += renderer.codespan(anyToken);
            break;
          case "br":
            out += renderer.br(anyToken);
            break;
          case "del":
            out += renderer.del(anyToken);
            break;
          case "text":
            out += renderer.text(anyToken);
            break;
          default:
            tokens = 'Token with "' + anyToken.type + '" type was not found.';
            if (this.options.silent) {
              return console.error(tokens), "";
            }
            throw Error(tokens);
        }
      }
      return out;
    }
  }
  class _Hooks {
    constructor(options) {
      this.options = options || exports.defaults;
    }
    static $jscomp$static$init$m219096014$0$passThroughHooks() {
      return new Set(["preprocess", "postprocess", "processAllTokens"]);
    }
    preprocess(markdown) {
      return markdown;
    }
    postprocess(html) {
      return html;
    }
    processAllTokens(tokens) {
      return tokens;
    }
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  }
  _Hooks.passThroughHooks = _Hooks.$jscomp$static$init$m219096014$0$passThroughHooks();
  class Marked {
    constructor(...args) {
      this.defaults = _getDefaults();
      this.options = this.setOptions;
      this.parse = this.parseMarkdown(!0);
      this.parseInline = this.parseMarkdown(!1);
      this.Parser = _Parser;
      this.Renderer = _Renderer;
      this.TextRenderer = _TextRenderer;
      this.Lexer = _Lexer;
      this.Tokenizer = _Tokenizer;
      this.Hooks = _Hooks;
      this.use(...args);
    }
    walkTokens(tokens, callback) {
      let values = [];
      for (const token of tokens) {
        switch(values = values.concat(callback.call(this, token)), token.type) {
          case "table":
            tokens = token;
            for (const cell of tokens.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tokens.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          case "list":
            values = values.concat(this.walkTokens(token.items, callback));
            break;
          default:
            const genericToken = token;
            this.defaults.extensions?.childTokens?.[genericToken.type] ? this.defaults.extensions.childTokens[genericToken.type].forEach(childTokens => {
              childTokens = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(childTokens, callback));
            }) : genericToken.tokens && (values = values.concat(this.walkTokens(genericToken.tokens, callback)));
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || {renderers:{}, childTokens:{}};
      args.forEach(pack => {
        const opts = {...pack};
        opts.async = this.defaults.async || opts.async || !1;
        pack.extensions && (pack.extensions.forEach(ext => {
          if (!ext.name) {
            throw Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            extensions.renderers[ext.name] = prevRenderer ? function(...args) {
              let ret = ext.renderer.apply(this, args);
              !1 === ret && (ret = prevRenderer.apply(this, args));
              return ret;
            } : ext.renderer;
          }
          if ("tokenizer" in ext) {
            if (!ext.level || "block" !== ext.level && "inline" !== ext.level) {
              throw Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            extLevel ? extLevel.unshift(ext.tokenizer) : extensions[ext.level] = [ext.tokenizer];
            ext.start && ("block" === ext.level ? extensions.startBlock ? extensions.startBlock.push(ext.start) : extensions.startBlock = [ext.start] : "inline" === ext.level && (extensions.startInline ? extensions.startInline.push(ext.start) : extensions.startInline = [ext.start]));
          }
          "childTokens" in ext && ext.childTokens && (extensions.childTokens[ext.name] = ext.childTokens);
        }), opts.extensions = extensions);
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new _Renderer(this.defaults);
          for (var prop in pack.renderer) {
            if (!(prop in renderer)) {
              throw Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop, rendererFunc = pack.renderer[rendererProp], prevRenderer = renderer[rendererProp];
            renderer[rendererProp] = (...args) => {
              let ret = rendererFunc.apply(renderer, args);
              !1 === ret && (ret = prevRenderer.apply(renderer, args));
              return ret || "";
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (var prop$jscomp$0 in pack.tokenizer) {
            if (!(prop$jscomp$0 in tokenizer)) {
              throw Error(`tokenizer '${prop$jscomp$0}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop$jscomp$0)) {
              continue;
            }
            prop = prop$jscomp$0;
            const tokenizerFunc = pack.tokenizer[prop], prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args) => {
              let ret = tokenizerFunc.apply(tokenizer, args);
              !1 === ret && (ret = prevTokenizer.apply(tokenizer, args));
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            prop$jscomp$0 = prop;
            const hooksFunc = pack.hooks[prop$jscomp$0], prevHook = hooks[prop$jscomp$0];
            _Hooks.passThroughHooks.has(prop) ? hooks[prop$jscomp$0] = arg => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => prevHook.call(hooks, ret));
              }
              arg = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, arg);
            } : hooks[prop$jscomp$0] = (...args) => {
              let ret = hooksFunc.apply(hooks, args);
              !1 === ret && (ret = prevHook.apply(hooks, args));
              return ret;
            };
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens = this.defaults.walkTokens, packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            walkTokens && (values = values.concat(walkTokens.call(this, token)));
            return values;
          };
        }
        this.defaults = {...this.defaults, ...opts};
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = {...this.defaults, ...opt};
      return this;
    }
    lexer(src, options) {
      return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
      return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(blockType) {
      return (src, options) => {
        options = {...options};
        const opt = {...this.defaults, ...options}, throwError = this.onError(!!opt.silent, !!opt.async);
        if (!0 === this.defaults.async && !1 === options.async) {
          return throwError(Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if ("undefined" === typeof src || null === src) {
          return throwError(Error("marked(): input parameter is undefined or null"));
        }
        if ("string" !== typeof src) {
          return throwError(Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        opt.hooks && (opt.hooks.options = opt, opt.hooks.block = blockType);
        const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline, parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(src => lexer(src, opt)).then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then(tokens => parser(tokens, opt)).then(html => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
        }
        try {
          opt.hooks && (src = opt.hooks.preprocess(src));
          let tokens = lexer(src, opt);
          opt.hooks && (tokens = opt.hooks.processAllTokens(tokens));
          opt.walkTokens && this.walkTokens(tokens, opt.walkTokens);
          let html = parser(tokens, opt);
          opt.hooks && (html = opt.hooks.postprocess(html));
          return html;
        } catch (e) {
          return throwError(e);
        }
      };
    }
    onError(silent, async) {
      return e => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          return e = "\x3cp\x3eAn error occurred:\x3c/p\x3e\x3cpre\x3e" + escape(e.message + "", !0) + "\x3c/pre\x3e", async ? Promise.resolve(e) : e;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
  }
  const markedInstance = new Marked();
  marked.options = marked.setOptions = function(options) {
    markedInstance.setOptions(options);
    marked.defaults = markedInstance.defaults;
    exports.defaults = marked.defaults;
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = exports.defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    exports.defaults = marked.defaults;
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  global = marked.options;
  require = marked.setOptions;
  module = marked.use;
  lheadingGfm = marked.walkTokens;
  hr = marked.parseInline;
  lheading = _Parser.parse;
  bullet = _Lexer.lex;
  exports.Hooks = _Hooks;
  exports.Lexer = _Lexer;
  exports.Marked = Marked;
  exports.Parser = _Parser;
  exports.Renderer = _Renderer;
  exports.TextRenderer = _TextRenderer;
  exports.Tokenizer = _Tokenizer;
  exports.getDefaults = _getDefaults;
  exports.lexer = bullet;
  exports.marked = marked;
  exports.options = global;
  exports.parse = marked;
  exports.parseInline = hr;
  exports.parser = lheading;
  exports.setOptions = require;
  exports.use = module;
  exports.walkTokens = lheadingGfm;
};

//# sourceMappingURL=module$node_modules$marked$lib$marked_cjs.js.map
